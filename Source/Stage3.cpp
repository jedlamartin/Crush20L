/*
  ==============================================================================

    Stage3.cpp
    Created: 21 Apr 2024 5:02:14pm
    Author:  Martin

  ==============================================================================
*/

#include "Stage3.h"

bool gluInvertMatrix(const juce::dsp::Matrix<float>& m, juce::dsp::Matrix<float>& outM) {
    juce::dsp::Matrix<float> inv(4, 4);
    double det;


    inv(0, 0) = m(1, 1) * m(2, 2) * m(3, 3) -
        m(1, 1) * m(3, 2) * m(2, 3) -
        m(1, 2) * m(2, 1) * m(3, 3) +
        m(1, 2) * m(3, 1) * m(2, 3) +
        m(1, 3) * m(2, 1) * m(3, 2) -
        m(1, 3) * m(3, 1) * m(2, 2);

    inv(0, 1) = -m(0, 1) * m(2, 2) * m(3, 3) +
        m(0, 1) * m(3, 2) * m(2, 3) +
        m(0, 2) * m(2, 1) * m(3, 3) -
        m(0, 2) * m(3, 1) * m(2, 3) -
        m(0, 3) * m(2, 1) * m(3, 2) +
        m(0, 3) * m(3, 1) * m(2, 2);

    inv(0, 2) = m(0, 1) * m(1, 2) * m(3, 3) -
        m(0, 1) * m(3, 2) * m(1, 3) -
        m(0, 2) * m(1, 1) * m(3, 3) +
        m(0, 2) * m(3, 1) * m(1, 3) +
        m(0, 3) * m(1, 1) * m(3, 2) -
        m(0, 3) * m(3, 1) * m(1, 2);

    inv(0, 3) = -m(0, 1) * m(1, 2) * m(2, 3) +
        m(0, 1) * m(2, 2) * m(1, 3) +
        m(0, 2) * m(1, 1) * m(2, 3) -
        m(0, 2) * m(2, 1) * m(1, 3) -
        m(0, 3) * m(1, 1) * m(2, 2) +
        m(0, 3) * m(2, 1) * m(1, 2);

    inv(1, 0) = -m(1, 0) * m(2, 2) * m(3, 3) +
        m(1, 0) * m(3, 2) * m(2, 3) +
        m(1, 2) * m(2, 0) * m(3, 3) -
        m(1, 2) * m(3, 0) * m(2, 3) -
        m(1, 3) * m(2, 0) * m(3, 2) +
        m(1, 3) * m(3, 0) * m(2, 2);

    inv(1, 1) = m(0, 0) * m(2, 2) * m(3, 3) -
        m(0, 0) * m(3, 2) * m(2, 3) -
        m(0, 2) * m(2, 0) * m(3, 3) +
        m(0, 2) * m(3, 0) * m(2, 3) +
        m(0, 3) * m(2, 0) * m(3, 2) -
        m(0, 3) * m(3, 0) * m(2, 2);

    inv(1, 2) = -m(0, 0) * m(1, 2) * m(3, 3) +
        m(0, 0) * m(3, 2) * m(1, 3) +
        m(0, 2) * m(1, 0) * m(3, 3) -
        m(0, 2) * m(3, 0) * m(1, 3) -
        m(0, 3) * m(1, 0) * m(3, 2) +
        m(0, 3) * m(3, 0) * m(1, 2);

    inv(1, 3) = m(0, 0) * m(1, 2) * m(2, 3) -
        m(0, 0) * m(2, 2) * m(1, 3) -
        m(0, 2) * m(1, 0) * m(2, 3) +
        m(0, 2) * m(2, 0) * m(1, 3) +
        m(0, 3) * m(1, 0) * m(2, 2) -
        m(0, 3) * m(2, 0) * m(1, 2);

    inv(2, 0) = m(1, 0) * m(2, 1) * m(3, 3) -
        m(1, 0) * m(3, 1) * m(2, 3) -
        m(1, 1) * m(2, 0) * m(3, 3) +
        m(1, 1) * m(3, 0) * m(2, 3) +
        m(1, 3) * m(2, 0) * m(3, 1) -
        m(1, 3) * m(3, 0) * m(2, 1);

    inv(2, 1) = -m(0, 0) * m(2, 1) * m(3, 3) +
        m(0, 0) * m(3, 1) * m(2, 3) +
        m(0, 1) * m(2, 0) * m(3, 3) -
        m(0, 1) * m(3, 0) * m(2, 3) -
        m(0, 3) * m(2, 0) * m(3, 1) +
        m(0, 3) * m(3, 0) * m(2, 1);

    inv(2, 2) = m(0, 0) * m(1, 1) * m(3, 3) -
        m(0, 0) * m(3, 1) * m(1, 3) -
        m(0, 1) * m(1, 0) * m(3, 3) +
        m(0, 1) * m(3, 0) * m(1, 3) +
        m(0, 3) * m(1, 0) * m(3, 1) -
        m(0, 3) * m(3, 0) * m(1, 1);

    inv(2, 3) = -m(0, 0) * m(1, 1) * m(2, 3) +
        m(0, 0) * m(2, 1) * m(1, 3) +
        m(0, 1) * m(1, 0) * m(2, 3) -
        m(0, 1) * m(2, 0) * m(1, 3) -
        m(0, 3) * m(1, 0) * m(2, 1) +
        m(0, 3) * m(2, 0) * m(1, 1);

    inv(3, 0) = -m(1, 0) * m(2, 1) * m(3, 2) +
        m(1, 0) * m(3, 1) * m(2, 2) +
        m(1, 1) * m(2, 0) * m(3, 2) -
        m(1, 1) * m(3, 0) * m(2, 2) -
        m(1, 2) * m(2, 0) * m(3, 1) +
        m(1, 2) * m(3, 0) * m(2, 1);

    inv(3, 1) = m(0, 0) * m(2, 1) * m(3, 2) -
        m(0, 0) * m(3, 1) * m(2, 2) -
        m(0, 1) * m(2, 0) * m(3, 2) +
        m(0, 1) * m(3, 0) * m(2, 2) +
        m(0, 2) * m(2, 0) * m(3, 1) -
        m(0, 2) * m(3, 0) * m(2, 1);

    inv(3, 2) = -m(0, 0) * m(1, 1) * m(3, 2) +
        m(0, 0) * m(3, 1) * m(1, 2) +
        m(0, 1) * m(1, 0) * m(3, 2) -
        m(0, 1) * m(3, 0) * m(1, 2) -
        m(0, 2) * m(1, 0) * m(3, 1) +
        m(0, 2) * m(3, 0) * m(1, 1);

    inv(3, 3) = m(0, 0) * m(1, 1) * m(2, 2) -
        m(0, 0) * m(2, 1) * m(1, 2) -
        m(0, 1) * m(1, 0) * m(2, 2) +
        m(0, 1) * m(2, 0) * m(1, 2) +
        m(0, 2) * m(1, 0) * m(2, 1) -
        m(0, 2) * m(2, 0) * m(1, 1);

    det = m(0, 0) * inv(0, 0) + m(1, 0) * inv(0, 1) + m(2, 0) * inv(0, 2) + m(3, 0) * inv(0, 3);

    if (det == 0)
        return false;

    det = 1.0 / det;


    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            outM(i, j) = inv(i, j) * det;
        }
    }
    return true;
}

void Stage3::configure(double sampleRate) {
    float T = 1 / sampleRate;
    float h = 2 * sampleRate;

    float R22 = 47000;
    float R33 = 6800;
    float R34 = 1000;
    float R35 = 2700;
    float R37 = 100000; //PARAMETER
    float C12 = 220e-9;
    float C18 = 470e-12;
    float E13 = 2.2e-6;
    float E14 = 2.2e-6;
    
    juce::dsp::Matrix<float> A(4, 4);
    juce::dsp::Matrix<float> B(4, 1) ;
    juce::dsp::Matrix<float> C(4, 1) ;
    juce::dsp::Matrix<float> D(1, 4) ;
    juce::dsp::Matrix<float> E(1, 1) ;
    juce::dsp::Matrix<float> F(1, 1) ;


    A(0, 0) = -1 / (C12 * (R37 + R34));
    A(0, 1) = 0;
    A(0, 2) = -1 / (C12 * (R37 + R34));
    A(0, 3) = 0;
    A(1, 0) = 1 / (C18 * (R37 + R34));
    A(1, 1) = -1 / (R22 * C18);
    A(1, 2) = 1 / (C18 * (R37 + R34));
    A(1, 3) = 0;
    A(2, 0) = -1 / (E13 * (R37 + R34));
    A(2, 1) = 0;
    A(2, 2) = -1 / (E13 * (R37 + R34));
    A(2, 3) = 0;
    A(3, 0) = 0;
    A(3, 1) = 0;
    A(3, 2) = 0;
    A(3, 3) = 0;

    B(0, 0) = -1 / (C12 * (R37 + R34));
    B(1, 0) = 1 / (C18 * (R37 + R34));
    B(2, 0) = -1 / (E13 * (R37 + R34));
    B(3, 0) = 0;

    C(0, 0) = 1 / C12 - R34 / (C12 * (R37 + R34));
    C(1, 0) = -R37 / (C18 * (R37 + R34));
    C(2, 0) = R37 / (E13 * (R37 + R34));
    C(3, 0) = -1 / E14;

    D(0, 0) = -R37 / (R37 + R34);
    D(0, 1) = 1;
    D(0, 2) = -R37 / (R37 + R34);
    D(0, 3) = 1;

    E(0, 0) = R34 / (R34 + R37);
    F(0, 0) = R34 * R37 / (R37 + R34);
    
    juce::dsp::Matrix<float> I(juce::dsp::Matrix<float>::identity(4));
    juce::dsp::Matrix<float> inv(4,4);
    gluInvertMatrix(I * h - A, inv);
    
    this->G = inv * C;
    this->H = inv * (I * h + A);
    this->J = inv * B;
    this->K = D * G + F;
}

Stage3::Stage3() :Stage(), G(4, 1), H(4, 4), J(4, 1), K(1, 1) {}
